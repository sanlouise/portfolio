Blog.create!(
  title: "Prototype Chains",
  body: "\r\n<p>Prototype chains are used to create objects that resemble other objects. When you want to build an object that basically has all properties that another already has, just copying them into your new object would be very repetitive. Prototype chains are a practical solution to this problem as they allow for failed property lookups on one object to delegate to another object. </p>\r\n\r\n<pre><code>var house = {a:roof};\r\nconsole.log(house.a); // roof\r\nconsole.log(house.g); // undefined</code></pre>\r\n\r\n<h5 class=center>Extend</h5>\r\n\r\n<p>We want to make an object that resembles our house variable, it this case <code>villa</code>. </p>\r\n\r\n<pre><code>var villa = extend({}, house);</code></pre>\r\n\r\n<p>This is one way to do it. With the extend method, all properties of house are copies onto our new villa object. However, this is a very static, one-time way of doing it - if we add other properties to our house object later in our code, these changes will be ignored. It is not an ongoing back-and-forth copying that keeps both objects synched.</p>\r\n\r\n<pre><code>var villa = extend({}, house);\r\nvilla.b = pool;\r\nconsole.log(villa.a); // roof\r\nconsole.log(villa.b); // pool\r\nconsole.log(villa.g); // undefined </code></pre>\r\n\r\n<h5 class=center>Object.create</h5>\r\n\r\n<p>Let’s use a different strategy and create a new, similar object! Instead of using the extend method that merely copies the properties of an object, let’s actually link our new <code>apartment</code> object to our <code>house</code> object. Whenever a property cannot be found on <code>apartment</code>, the failed lookup is delegated to <code>house.</code>. This delegation lookup feature can be created with <code>Object.create</code>.</p>\r\n\r\n<pre><code>var apartment = Object.create(house);\r\napartment.b = floor;\r\nconsole.log(apartment.a) //roof\r\nconsole.log(apartment.b) //floor (the prototype chain is never consulted)\r\nconsole.log(apartment.g) //undefined </code></pre>\r\n\r\n<p>Here, our desired fallback object is <code>house</code>, and failed property lookups are delegated to that object. The objects are synched and the successful property lookup is not a result of a prior, one-time copying process.</p> \r\n\r\n<h5 class=center>Key Difference</h5>\r\n\r\n<p>To clarify the difference between the <code>extend</code> and the <code>Object.create</code> methods, let’s look at this piece of code:</p>\r\n<pre><code>var apartment = Object.create(house);\r\napartment.b = floor;\r\nconsole.log(apartment.a) //roof\r\nconsole.log(apartment.b) //floor (the prototype chain is never consulted)\r\nconsole.log(apartment.g) //undefined \r\n\r\nhouse.g = window\r\nconsole.log(villa.g);\r\n</code></pre>\r\n\r\n<p> What do you think <code>console.log(villa.g)</code> will result into? The right answer is: undefined! Our <code>villa</code> object only copies the properties that are given to the <code>house</code> object before it is declared itself! The only property <code>villa</code> has access to, is roof!</p>\r\n\r\n<p>Instead, if we log the <code>g</code> property of the <code>apartment object </code>, window is returned! The <code>house</code> and <code>apartment</code> properties are in sync.<p>\r\n\r\n<h4 class=center>The Object Prototype</h5>\r\n<p>There are more objects in Javascript that make use of the mechanism that keeps objects in sync. For instance, <code>house</code> will also delegate its failed lookups somewhere! In fact, there is a top-level Javascript object that all objects eventually will delegate their failed lookups to: the object prototype! It is at this level where all basic and shared methods are provided for all objects in the entire system (for example, think of <code>.toString</code> or <code>.valueOf)</code>.</p>\r\n\r\n<p>One of the most helpful object prototypes is the constructor property. The <code>constructor </code> is used to see which function is responsible for the creation of a specific object. </p>\r\n\r\n<h4 class=center>The Array Prototype</h5>\r\n<p>Although almost all objects in Javascript will delegate to the object prototype, there are a few special objects that have extra features that go above the basic characteristics of objects. For example, an array also has methods such as <code>slice</code> and <code>indexOf</code>. These methods are called in the array prototype. The array prototype delegates to the object prototype - most methods between the two are similar, and the array prototype simply inherits many methods to avoid duplication.<p>\r\n\r\n<i>This post was inspired by the course on Object-Oriented Javascript by Udacity and Hack Reactor.</i>",
  topic: "Javascript",
  created_at: "2016-03-29"
)
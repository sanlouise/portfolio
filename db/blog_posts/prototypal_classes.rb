user = User.first

user.blogs.create!(
  title: "Prototypal Classes",
  body: "<section class=\"blog-font blog-post\">\r\n<p></p>\r\n\r\n<h4></h4>\r\n  \r\n<p>In my <a href=\"http://www.sandrahallie.com/blogs/1\">post on functional classes</a>, we left off with the code below. In this post, we will\r\ntry to make use of a prototype chain which could improve performance. The main goal of the \r\nprototypal pattern is function sharing.</p>\r\n\r\n<p>library.js</p> \r\n<pre><code>var Tiger = function(loc) {\r\n  obj.loc = {loc: loc};\r\n  extend(obj, Tiger.methods);\r\n  return obj;\r\n};\r\n\r\nTiger.methods = {\r\n  move : function() {\r\n    this.loc++;\r\n\t},\r\n  jump : function() { … },\r\n  run : function() { … }\r\n};\r\n</code></pre>\r\n\r\n<p>run.js</p>\r\n<pre><code>var bobo = Tiger(2);\r\nbobo.move();\r\nvar nola = Tiger(7);\r\nnola.nove();\r\n</code></pre>\r\n\r\n<p>Any object can make its failed property lookups delegate to another (prototypal) object.</p>\r\n<p>With this in mind, we can choose to delete the <code>extend()</code> method which simply copies\r\nall properties it is linked to, to our objects. Instead we can delegate failed property lookups \r\nwith a prototype lookup! This can save us a lot of memory. </p> \r\n\r\n<p>One problem with out current code is that we use an object literal to create our objects.\r\nThis disallows us from defining the prototype of our object.</p>\r\n<pre><code>var obj = {loc: loc};\r\n</code></pre>\r\n\r\n<p>We'll need to rework our code a bit! Let's use <code>Object.create</code>, which does allow us to set\r\na prototype for our object. Whatever is in the parenthesis is where our object delegates to.</p>\r\n\r\n<pre><code>var obj = Object.create(Tiger.methods)\r\n</code></pre>\r\n\r\n<p>Now we can also get rid off <code>extend(obj, Tiger.methods)</code>because our object \r\nalready has access to all properties of <code>Tiger.methods</code>. Because we are not \r\nusing an object literal anymore, we do need to make a reference to (loc) somewhere in our class. </p>\r\n\r\n<pre><code>var Tiger = function(loc) {\r\n  var obj = Object.create(Tiger.methods);\r\n  obj.loc  = loc\r\n  return obj;\r\n};\r\n\r\nTiger.methods = {\r\n  move : function() {\r\n    this.loc++;\r\n\t},\r\n  jump : function() { … },\r\n  run : function() { … }\r\n};\r\n</code></pre>\r\n\r\n<p>Our class now conforms to the prototypal pattern!</p>\r\n<h4>A quick sum-up:</h4>\r\n<p>So far, our delegation looks pretty simple! The code we have written includes a class \r\nthat allows us to make instances, a line of that function that generates that new instance, \r\na delegation from the object to a prototype, and some code that makes an object unique \r\nfrom the other objects in the same class.</p>\r\n\r\n\r\n<h5 class= \"center\">Using <code>.prototype</code> </h5>\r\n\r\n<p>Because delegation is so common, there are targeted Javascript methods available that makes it easier for \r\nprogrammers to use delegation repeatedly. In fact, whenever a function is created, it will have \r\na default object attached to it that can be used as a method container! The code below \r\nreflects this, and you'll see that we have even been enabled to take out our object literal. For simplicity, \r\nI've removed the run and jump methods. This does look quite simple, right? </p>\r\n\r\n<pre><code>var Tiger = function(loc) {\r\n  var obj = Object.create(Tiger.prototype);\r\n  obj.loc  = loc\r\n  return obj;\r\n};\r\n\r\nTiger.prototype.move = function() {\r\n  this.loc++\r\n};\r\n</code></pre>\r\n\r\n<h5 class= \"center\">Now don't be confused!</h5>\r\n\r\n<p>There are no trippy, confusing rules that come with the <code>.prototype</code> \r\ncontainer! We only changed the name to match Javascript convention - there are no changes \r\nto the in-memory model. Note that you do need the <code>Object.create</code> method in \r\nyour class to delegate to the prototype.</p>\r\n\r\n<h5 class= \"center\">Constructors</h5>\r\n<p>The <code>.prototype</code> objects come with comes with an extra convenience property, \r\n<code>.constructor</code> that points back to the function it came attached to. \r\nUsing constructors is handy when you want to figure out which function created a specific\r\nobject. We can write constructor methods like so:</p>\r\n\r\n<pre><code>console.log(Tiger.prototype.constructor);</code></pre>\r\n\r\n<p>In this example, the constructor points to the <code>.move</code> function. </p>\r\n\r\n<h5 class= \"center\">instanceOf</h5>\r\n\r\n<p>Let's look at this piece of code:</p>\r\n\r\n<pre><code>console.log(bobo instanceOf Tiger);</code></pre>\r\n\r\n<p>Here, the boolean <code>instanceOf</code> checks if the right operands prototype object \r\ncan be found anywhere in the left operands prototype chain. In our case, this will evaluate to true.\r\n</p>\r\n\r\n<p>My <a href=\"http://www.sandrahallie.com/blogs/4\">next blog post </a>will be about further refactoring our code.</p>\r\n \r\n<i>This post was inspired by the course on Object-Oriented Javascript by Udacity and Hack Reactor.</i>\r\n\r\n</section>",
  topic: "JavaScript",
  created_at: "2016-03-27"
)
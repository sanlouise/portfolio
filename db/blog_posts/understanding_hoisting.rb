user = User.first

user.blogs.create!(
  title: "Understanding Hoisting",
  body: "<p>Before executing code, Javascript moves variable declarations to the top of the scope. This is hoisting.</p>\r\n\r\n<p>Let’s look at this code:</p>\r\n\r\n<code><pre>function loadProfiles(users){\r\n    if(users.length > 4){\r\n        var loadMessage = “Loading the users can take a moment.”\r\n        _displaySpinner(loadMessage);\r\n    }else{\r\n        var flashMessage = “Loading…”;\r\n        _displayFlash(flashMessage);\r\n    }\r\n\r\n}</pre></code>\r\n\r\n<p>It is important to know that, because of hoisting, Javascript moves both the loadMessage and flashMessage methods into the highest scope of the function. Note that variables and parameters declared inside a function are local to that function, they are not available in the global scope. Our program reads the variables like this:</p>\r\n\r\n<code><pre>function loadProfiles(users){\r\n    var loadMessage, flashMessage;\r\n\r\n    if(users.length > 4){\r\n        var loadMessage = “Loading the users can take a moment.”\r\n        _displaySpinner(loadMessage);\r\n    }else{\r\n        var flashMessage = “Loading…”;\r\n        _displayFlash(flashMessage);\r\n    }\r\n\r\n}</pre></code>\r\n\r\n<h4 class=“center”>Hoisting Functions</h4>\r\n\r\n<p>Hoisting works the same with functions. For example, consider this code:</p>\r\n\r\n<code><pre>function getNumber() {\r\n    function chooseNumber() {\r\n        return 10;\r\n    }\r\n\r\n    return chooseNumber();\r\n\r\n    function chooseNumber() {\r\n       return 20;\r\n    }\r\n}</pre></code>\r\n<p>What do you think will be returned? Well, thanks to hoisting, our code loads like this:</p>\r\n\r\n<code><pre>function getNumber() {\r\n    function chooseNumber() {\r\n        return 10;\r\n    }\r\n\r\n    function chooseNumber() {\r\n       return 20;\r\n    }\r\n    return chooseNumber();\r\n}</pre></code>\r\n\r\n<p>Therefore, we’ll get a 20 returned. Our original chooseNumber function is overwritten.</p>\r\n\r\n<h5 class=“center”>Hoisting & Function Expressions</h5>\r\n\r\n<p>It is very important to note that function expressions are never hoisted! They are instead treated as assignments. Look at this:</p>\r\n\r\n<code><pre>function getNumber() {\r\n    var chooseNumber = function() {\r\n        return 10;\r\n    }\r\n\r\n    return chooseNumber();\r\n\r\n    var chooseNumber = function() {\r\n        return 20;\r\n    }\r\n}</pre></code>\r\n\r\n<p>Right when chooseNumber is returned, our program calls chooseNumber and we’ll get a result of 10. Our program looks no further. The second chooseNumber function is in fact unreachable! It is important to always declare a function expression before calling it.</p>\r\n\r\n<h4 class=“center”>Hoisting in Loops</h4>\r\n\r\n<p>Hoisting can get problematic. For instance, consider this example:</p>\r\n\r\n<code><pre>function loadProfiles(users)\r\n    for(var i in users) {\r\n        _fetchProfile(“/users/“ + users[i], function () {\r\n            console.log(“Fetched user :”, users[i]);\r\n        }\r\n    }\r\n}</pre></code>\r\n\r\n<p>Let’s assume we have an array of 4 users. We are trying to log each fetched user. However, that’s not what will happen. Only the last user will be printed, 4 times! This happens because of hoisting.</p>\r\n\r\n<p>Look at this line in particular: <code>console.log(“Fetched user :”, users[i]);</code>. It is trying to access <code>i</code> from within the callback.</p> \r\n\r\n<p>Javascript interprets our code like this:</code>\r\n\r\n<code><pre>function loadProfiles(users)\r\n    var users;\r\n    for(i in users) {\r\n        _fetchProfile(“/users/“ + users[i], function () {\r\n            console.log(“Fetched user: ”, users[i]);\r\n        }\r\n    }\r\n}</pre></code>\r\n\r\n<p>The variable <code>i</code> is hoisted to the top of the function and is thus also shared amongst all iterations of the for-loop. Method fetchProfile is called four times before the subsequent callback is invoked. Variable <code>i</code> is increased on each iteration, and at the moment when the callback is invoked, <code>i</code> holds the very last value assigned to it from the for-loop.</p>\r\n\r\n<h5 class=“center”>ES2015 Solution: ‘Let’</h5>\r\n\r\n<p>With ES2015, there is a way to fix this unexpected behavior: using the keyword <code>let</code>. The <code>let</code> variable is scoped to the nearest block and is not visible outside of the block. Also, with <code>let</code>, there is no variable sharing. Each iteration creates a new variable. In other words, each callback function have their own value of <code>i</code>.</p>\r\n\r\n<p>A note on <code>let</code>, variables declared with let cannot be redeclared within the same scope. However, they can be reassigned.</p>\r\n\r\n<p>This is wrong and returns a TypeError: <code><pre>let flashMessage = “Hello”;\r\nlet flashMessage = “Hey”;</pre></code></p>\r\n\r\n<p>This is OK: <code><pre>let flashMessage = “Hello”;\r\nflashMessage = “Hey”;</pre></code></p>\r\n\r\n<p><i>This post was inspired by ES2015 course on CodeSchool.</i></p>\r\n\r\n",
  topic: "Javascript",
  created_at: "2016-06-21"
)
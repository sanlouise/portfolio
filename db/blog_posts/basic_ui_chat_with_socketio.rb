user = User.first

user.blogs.create!(
  title: "Basic UI Chat with Socket.io (3/3)",
  body: "<p>If you’ve followed along with me with  <a href=\"http://www.sandrahallie.com/blogs/14\">my latest post</a>, you now got the code needed in the back-end that allows for cross-browser instant communication. This is the perfect basis for a chat application. Although this is awesome, it would be even better to set up a basic UI so that we don’t have to do everything in the terminal anymore but can type messages on an actual web page.</p>\r\n\r\n<h4 class=“center”>Adding Form Submission UI</h4>\r\n<p>In public/index.html, add the following code in the body, right above the script tags.</p>\r\n\r\n<p><code><pre><xmp><form id=\"message-form\">\r\n    <input type=\"text\" name=\"message\"/>\r\n    <input type=\"submit\"/>\r\n</form></xmp></pre></code></p>\r\n\r\n<p>We can now easily target this form using the ID ‘message-form’, which should enable us to send a message and then submit whatever we wrote. We need some javascript to make this work.</p>\r\n\r\n<p>At the bottom of your app.js file, add the following line: <code>var $form = jQuery(‘#message-form’);</code>. This is typical jQuery syntax, and in this case it selects our form with its given ID. Then, we need a way to know whether the user has submitted the form by clicking the submit button or hitting the return button.</p>\r\n\r\n<p><code><pre>var $form = jQuery('#message-form');\r\n$form.on('submit', function (event) {\r\n    event.preventDefault();\r\n    var $message = $form.find('input[name=message]');\r\n\r\n    socket.emit('message', {\r\n        text: $message.val()\r\n    });\r\n    $message.val('');\r\n});</pre></code></p>\r\n\r\n<p>We are using <code>event.preventDefault()</code> here to avoid submitting data the normal way, by refreshing the page. The <code>’input[name=message]’</code> selector is now selecting any text transmitted via the input field with name attribute ‘message’. Lastly, we want to ensure that the input field turns empty once we hit return or the submit button. We do this by passing in an empty string. This is great! Now we have the front-end in place to submit a message to the server! </p>\r\n\r\n<h4 class=“center”>Showing Incoming Messages</h4>\r\n<p>To create an extremely basic layout that displays incoming messages, we only need to do two things. First, in index.html, add an empty div right above the form. Give the div a class called ‘messages’. Your final index.html will look like this:</p>\r\n\r\n<p><code><pre><xmp><!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title>Simple Socket.io</title>\r\n    </head>\r\n    <body>\r\n\r\n        <div class=\"messages\">\r\n            <!-- Here I will display messages -->\r\n        </div>\r\n\r\n        <form id=\"message-form\">\r\n            <input type=\"text\" name=\"message\"/>\r\n            <input type=\"submit\"/>\r\n        </form>\t\r\n\r\n        <script src=\"/js/jquery-2.2.4.min.js\"></script>\r\n        <script src=\"/js/socket.io-1.3.7.js\"></script>\r\n        <script src=\"js/app.js\"></script>\r\n\r\n    </body>\r\n</html></xmp></pre></code></p>\r\n\r\n<p>The second and last thing we really need to do is add a jQuery event in our app.js that ensures incoming messages are added into our newly created div. Update your emit listener in app.js to match the following code:</p>\r\n\r\n<p><code><pre><xmp>socket.on(‘message', function (message) {\r\n    console.log('New message:');\r\n    console.log(message.text);\r\n\r\n    jQuery('.messages').append('<p>' + message.text + '</p>');\r\n});</xmp></pre></code></p>\r\n\r\n<p>In the last line, messages are appended to the div you’ve just created in index.html. Restart your server, open two browsers, navigate to localhost:3000 and see the magic in action!</p>\r\n\r\n\r\n<h5 class=“center”>Fix an Inconvenience</h5>\r\n<p>In server.js we specified that we only wanted the messages returned that came from the other person. You might have noticed that this is very inconvenient - it is hard to keep track of conversations when your own messages are not displayed. We need to make a minor change in server.js. Update <code>socket.broadcast.emit(‘message’, message);</code> to <code>io.emit(‘message’, message);</code>.\r\n\r\n<h4 class=“center”>Adding Timestamps</h4>\r\n<p>We’ll use the MomentJS library. Run <code>npm install moment --save</code> in your terminal. Then, add a new file under public/js and call it moment.js. Paste in the code you can find here: http://momentjs.com/downloads/moment.js.</p>\r\n\r\n<p>Now, require MomentJS in your server.js file with this line: <code>var moment = require(‘moment’);</code>.</p>\r\n\r\n<p>Now, update server.js so that your connection listener looks like this:</p>\r\n\r\n<code><pre>io.on('connect', function (socket) {\r\n    console.log('User is connected via socket.io!');\r\n\r\n    socket.on('message', function (message) {\r\n        console.log('Your message was received: ' + message.text);\r\n        message.timestamp = moment().valueOf();\r\n        io.emit('message', message);\r\n    });\r\n\r\n    socket.emit('message', {\r\n        text: 'Welcome to Chatty!',\r\n        timestamp: moment.valueOf()\r\n    });\r\n});</pre></code>\r\n\r\n<p>Then, in app.js, update the jQuery event listener like this:</p>\r\n<code><xmp>jQuery('.messages').append('<p><strong>' + momentTimestamp.local().\r\nformat(‘h:mm a') + ‘</strong>: ' + message.text + ‘</p>’);</xmp></code>\r\n\r\nWhen you rerun your server, you should now see a time printed in front of the messages. So cool! Note, you can easily modify how time is displayed by looking at the MomentJs documentation.</p>\r\n",
  topic: "JavaScript",
  created_at: "2016-06-16"
)
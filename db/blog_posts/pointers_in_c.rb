Blog.create!(
  title: "Pointers in C",
  body: "<h4 class=“center”>Pointers</h4>\r\n\r\n<p>Understanding pointers is incredibly useful, even if you don’t program in C. Many programming tasks in C are simplified with pointers, and pointers are crucial to the conceptualization of memory allocation and layout. Before heading to some practical examples, let’s first make sure we understand some super basic memory principles.</p>\r\n\r\n<h5 class=“center”>Memory Layout In Programs</h5>\r\n<p>Memory is divided in blocks of either 32 or 64 bits, depending on your OS. Each block has an accessible address. Addresses are represented in hexadecimal values. You don’t have much control over where your variable will be stored, addresses are determined by the C program. Because the hexadecimal values are complicated to work with, we instead use variables that symbolically represent some address in memory.</p>\r\n\r\n<h5 class=“center”>Information Storage in Memory</h5>\r\n<p>Let’s consider the following example:</p>\r\n\r\n<code><pre>int width = 30;\r\nint length = 50;</pre></code>\r\n\r\n<p>In this example, width and length are the variable names. Both these variable names symbolically refer to a location in memory. For width, 30 is the value stored in that location - a location that has an address known by the C program.</p>\r\n\r\n<h5 class=“center”>How Much Space Do Variables Occupy</h5>\r\n<p>Different types of variables occupy different amounts of space. Although the exact values are machine dependent, we can now keep these values in mind:</p>\r\nIntegers - 4 bits, floats - 4 bits, chars - 1 bit. Also, 8 bits equal 1 byte.\r\n\r\n\r\n<h4 class=“center”>What Are Pointers</h4>\r\n<p>We have <code>int width = 30;</code>. Let’s assume that the value 30 is stored in memory with the hexadecimal value 125FB. Now we want to point to that location. In order to do that, we need to set up another variable: <code>widthPtr</code>. This variable now stores the hexadecimal location of <code>width</code>, but because it is a completely new variable it has its own location in memory: 13FF. All what pointers do is holding the memory address of another variable.</p>\r\n\r\n<h5 class=“center”>Setting Up Pointers</h5>\r\n<p>Setting up pointers is actually very easy! This is how we can do it:</p>\r\n<code><pre>int *widthPtr = &width;</pre></code>\r\n<p>The <code>int * </code>part indicates we are pointing to an integer, <code>&</code> tells we need an address.</p>\r\n<p>Pointers need to know what type they point to for pointer arithmetic purposes. More on this later. Pointers can point to any type of variable, like this: <code>int *intPtr, char *charPtr, float *floatPtr</code>. </p>\r\n\r\n<h5 class=“center”>Common Usage</h5>\r\n<p>Let’s look at these lines of code:</p>\r\n<code><pre>int width = 30;\r\nint *widthPtr = &width;\r\nint *otherWidthPtr;\r\notherWidthPtr = widthPtr;</pre></code>\r\n\r\n<p>On line 2, note that we specify the type to which the pointer points. On line 3, we declare a new pointer to an integer. Then on line 4, you see that pointers can be assigned like any other variable. Line 4 ensures that otherWidthPtr stores the memory location of width: 125FB.</p>\r\n\r\n<h5 class=“center”>Accessing Value a Pointers Points to</h5>\r\n<p>This is fairly simple! Look at this: <code>int r = *widthPtr;</code>, here the new variable r is a completely new variable in a new memory location and holds the value 30. Using * before a pointer indicates that we want to get the value of that pointer - dereferencing the pointer.</p>\r\n\r\n<h4 class=“center”>Some Practice</h4>\r\n<li><p><strong>What does this code print with our previous code setup in mind? <code>printf (“%u”, &width);</code></strong> - <i>(Prints the address of width.)</i></p></li>\r\n\r\n<p>Note that <code>%u</code> stands for unassigned decimal integer. You can find more info about formatting escapes <a href=“http://www.cplusplus.com/reference/cstdio/printf/\">here</a>.</p>\r\n\r\n<li><p><strong>What does this code print? <code>printf (“%d”, *widthPtr);</code></strong> - <i>(Prints the value of width, 30. This is called dereferencing a pointer.)</i></p></li>\r\n\r\n<li><p><strong>What does this code print? <code>printf (“%d”, *&width);</code></strong> - <i>(Also prints the value of width, 30. We need to read from right to left: first we get the address of the width variable and then deference the address.)</i></p></li>\r\n\r\n<li><p><strong>What does this code print? <code>printf (“%u”, widthPtr);</code></strong> - <i>(Prints the address of width: 125FB.)</i></p></li>\r\n\r\n\r\n<li><p><strong>What does this code print? <code>printf (“%u”, &widthPtr);</code></strong> - <i>(Prints the address of widthPtr, which is not 125FB but 13FF.)</i></p></li>\r\n\r\n<li><p><strong>What does this code print? <code>printf (“%u”, &otherWidthPtr);</code></strong> - <i>(Prints the address of otherWidthPtr.)</i></p></li>\r\n\r\n<h4 class=“center”>Arrays in C Are Pointers</h4>\r\n\r\n<p>Hopefully you are familiar with the concept of arrays. Suppose we have this array: <code> int arr[4] = { 1, 2, 3, 4 };</code>. This is more than an array of integers, and not just a continuous block of memory! Let’s take a look at how arrays are laid out in memory.</p>\r\n\r\n<p>In our array example, we can access all elements like this: arr[0], arr[1], arr[2], arr[3]. All elements in the array have addresses associated to them - and since we know that integers occupy 4 bits, these contiguous memory locations could look something like this: 1024, 1028, 1032, 1036.</p>\r\n\r\n<p>Array variables are pointers, and we can treat them equally! In our case, we have an integer array, so we should treat its elements exactly like integer pointers, <code>int*</code>. Important is that <code>arr</code> on itself points to the address location of the very first array element. Thus, <code>arr</code> holds the same address as <code>&arr[0]</code>.</p>\r\n\r\n<h4 class=“center”>Pointer Arithmetic</h4>\r\n<p>Performing increment operations is also called pointer arithmetic. With this code in mind: <code>int *intPtr = arr</code>, we’ll perform <code>intPtr++;</code>. What do you think will happen?</p>\r\n\r\n<p>In C, with pointer arithmetic we can access all elements in an array once we know the first element. So, <code>intPtr++;</code> will move arr[0] to arr[1], in memory a jump of 4 bits. If we dereference this element, we’ll get the value 2.</p>\r\n\r\n<p>Once we know the type of an array, and thus know how much space each element of the array occupies, and also know the address of the first element in the array, we can easily calculate the other addresses of the elements in the array. We just need to add the additional memory space to the initial element of the array. Pretty simple. For example, if we want the value of the second element in the array, we can just type <code>*(arr+1)</code>.</p>\r\n\r\n<h5 class=“center”>Pointer Types</h5>\r\n<p>The logic above explains why pointer types are useful. When performing increment operations, the program knows how much memory each element occupies and can thus jump to different memory locations.</p>\r\n\r\n<h5 class=“center”>Character Arrays</h5>\r\n<p>All of the above statements also count for character arrays. The only difference is that characters occupy 1 bit, so the address in memory location is incremented by 1 once we perform increment operations. Note that strings are character arrays! <code>char* str = “Hello World”;</code> In memory, a string looks just like a character array but with one important addition: it is terminated by <code>\\0</code>, which tells the compiler it is the end of a string.</p>\r\n\r\n<p>We can print an entire string like this: <code>printf(“%s”, str);</code>. Had we wanted to only print the first character, we could have written this: <code>printf(“%s”, *str);</code>. The third character could be retrieved like this: <code>printf(“%s”, *(str + 2));</code>, or like this: <code>printf(“%s”, str[2]);</code>\r\n\r\n<h4 class=“center”>Some Problems</h4>\r\n\r\n<p>What does this code print?</p>\r\n<code><pre>int length = 10;\r\nint width = 5;\r\n\r\nint *lengthPtr = &length;\r\nint *widthPtr = &width;\r\n\r\nprintf(“%p\\n”, lengthPtr);\r\nprintf(“%p\\n”, widthPtr);</pre></code>\r\n<p>Here, we don’t dereference the pointers. Instead, we print the memory addresses of length and width! Note that ‘p’ stands for pointer address.</p>\r\n\r\n<p>Some more practice. What does this code print?</p>\r\n\r\n<code><pre>int length = 10;\r\nint width = 5;\r\n\r\nint *lengthPtr = &length;\r\nint *widthPtr = &width;\r\n\r\nint *test = lengthPtr;\r\n*test = 25;\r\n\r\nprintf(“%d\\n”, length);\r\nprintf(“%d\\n”, width);</pre></code>\r\n\r\n<p>Here, the outcome is 25 and 5. Let’s break that down. We have lengthPtr and test that both hold the memory location of length at independent memory locations. Thus, *lengthPtr refers to the value associated with length, 10. The exact same goes for *test, which initially also refers to the value 10. However, *test accesses the length value and then updates it to 25.</p>\r\n\r\n<p>One more exercise! What numbers does this code print?</p>\r\n\r\n<code><pre>int length = 10;\r\nint width = 5;\r\n\r\nint *lengthPtr = &length;\r\nint *widthPtr = &width;\r\n\r\nint *test = lengthPtr;\r\n*test = 25;\r\n\r\nprintf(“%d\\n”, length);\r\nprintf(“%d\\n”, width);\r\n\r\ntest = widthPtr;\r\n*test = 20;\r\n\r\nprintf(“%d\\n”, length);\r\nprintf(“%d\\n”, width);\r\n\r\n</pre></code>\r\n\r\n<p>The outcome is: 25, 5, 25 and 20. Both length and width are updated by the test value.</p>\r\n\r\n<i>This post was inspired by the course 'Break Away: Programming And Coding Interviews' by Loony Corn.</i>",
  topic: "CS Fundamentals",
  created_at: "2016-07-01"
)
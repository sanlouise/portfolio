Blog.create!(
  title: "Higher Order Components in React",
  body: "<h4 class=“center”>Building Objects with Object.create</h4>\r\n\r\n<p>With inheritance, we can create new Objects using our existing Objects as their prototypes. </p>\r\n\r\n<p>Let’s create a new bag Object.</p>\r\n<code><pre>var bag = { brand: “Baggy”, color: “red”, size: “large”, gender: “women” };</pre></code>\r\n\r\n<p>We can use this Object as a prototype for other Objects, like this:</p>\r\n<code><pre>var fancyBag = Object.create( bag );</pre></code>\r\n\r\n<p>Now, if we log <code>fancyBag</code>, we get the exact same properties as our <code>bag</code> object.</p>\r\n\r\n<p>We can easily add properties to our new object, just like this:</p> <code><pre>fancyBag.jewels = “diamonds”; \r\nfancyBag.zipper = “silver”;\r\nfancyBag.accessories = 4;</pre></code>\r\n\r\n<h5 class=“center”>Understanding Our Bag Inheritance</h5>\r\n<p>Using <code>.isPrototypeOf</code> we can find out whether a specific Object is a prototype of another Object. Let’s check if <code>bag</code> is a prototype of <code>fancyBag</code>. Well, <code>bag.isPrototypeOf( fancyBag );</code> returns true.</p>\r\n\r\n<p>Of course, <code>Object.prototype.isPrototypeOf( fancyBag );</code> will also return true. The method looks upward through the complete hierarchy (the prototype chain) to check whether it can detect a prototypal ancestor for <code>fancyBag</code>.</p>\r\n\r\n\r\n<h5 class=“center”>Building Prototypes With Empty Properties</h5>\r\n<p>Using a generic <code>bag</code>, we can create all sorts of bags and assign properties later. However, this really is far from ideal. We repeat ourselves a lot. Look at this:</p>\r\n\r\n<code><pre>var bag = { brand: undefined, color: undefined, size: undefined, gender: undefined };\r\n\r\nvar mensBag = Object.create( bag );\r\n\r\nmensBag.brand = “Prada”;\r\nmensBag.color = “black”;\r\nsize: “medium”;\r\ngender: “men”;\r\n\r\nvar beachBag = Object.create( bag );\r\n\r\nbeachBag.brand = “Beach Lovers”;\r\nbeachBag.color = “sand”;\r\nbeachBag.size: “large”;\r\nbeachBag.gender: “unisex”;</pre></code>\r\n\r\n<p>See, way too much typing!</p>\r\n\r\n<h4 class=“center”>Creating a Bag Class</h4>\r\n\r\n<p>A better solution is building a class, a basic prototype, from which Objects can inherit properties. Let’s build a constructor for our Bag class.</p>\r\n\r\n<h5 class=“center”>Building a Constructor Function</h5>\r\n\r\n<code><pre>function Bag (brandBag, bagColor, bagSize, forGender) {\r\n    this.brand = bagBrand;\r\n    this.color = bagColor;\r\n    this.size = bagSize;\r\n    this.gender = forGender;\r\n    this.carryBag = function () { alert(“Carry the bag!”); };\r\n}</pre></code>\r\n\r\n<p>We capitalized ‘Bag’, which indicates it is a maker of a class of Objects, a constructor. The function parameters are specific values for specific types of bags. The <code>this</code> keyword inside of the constructor function refers to the new instance of the class that is being created.</p>\r\n\r\n<h5 class=“center”>Using a Constructor Function</h5>\r\n\r\n<code><pre>var handBag = new Bag( “Marc Jacobs”, “red”, “small”, “women” );</pre></code>\r\n<p>The keyword <code>new</code> requests the making of a new instance of a Bag.</p>\r\n\r\n<p>Adding a property to our newly created Bag instance is easy!</p>\r\n\r\n<code><pre>handBag.pockets = 3;</pre></code>\r\n\r\n<h4 class=“center”>Inheritance</h4>\r\n\r\n<p>Where did we make use of inheritance? Well, we didn’t. We created an Object builder but we haven’t used the concept of Javascript inheritance. Our constructor function just builds an Object, and all properties that each newly created bag has, belong to that specific bag. They are not stored elsewhere.\r\n\r\n<h5 class=“center”>Efficient Data Storage</h5>\r\n<p>Let’s see what properties of <code>Bag</code> are the same for each instance. In our case, it is just our <code>carryBag</code> functionality. We can extract this property so that it is stored in one location that is easily accessible by all other instances of <code>Bag</code>. Doing so, every new instance will refer to it for the extra property.</p>\r\n\r\n<code><pre>Bag.prototype = {\r\n    carryBag: function () { alert(“Carry the bag!”); };\r\n};</pre></code>\r\n<p>We save a lot of data doing this - especially had we assigned more properties to our constructor prototype. Our constructor function is now smaller, and each newly created <code>Bag</code> Object will contain less data.</p>\r\n\r\n<code><pre>function Bag (brandBag, bagColor, bagSize, forGender) {\r\n    this.brand = bagBrand;\r\n    this.color = bagColor;\r\n    this.size = bagSize;\r\n    this.gender = forGender;\r\n}</pre></code>\r\n\r\n<h5 class=“center”>Prototypes Referring to Instances</h5>\r\n\r\n<p>Look what we can do! The <code>this</code> keyword looks at the specific <code>Bag</code> that called the inherited function, and then pulls the property data from it.</p>\r\n\r\n<code><pre>Bag.prototype = {\r\n    carryBag: function () { alert(“Carry the ” + this.color + “ bag!”); };\r\n};</pre></code>\r\n\r\n<p><i>This post was inspired by the Javascript Roadtrip Part 3 from CodeSchool.</i></p>",
  topic: "JavaScript",
  created_at: "2016-06-30"
)
Blog.create!(
  title: "The Object Decorator Pattern",
  body: "<section class=\"blog-font blog-post\">\r\n<p>Whenever parts of your code have similarities, there is an \r\nopportunity to factor out these similar aspects into reusable code \r\nso you won’t have to violate the “Do not repeat yourself’ principle \r\nof software engineering. \r\n</p>\r\n\r\n<h4>What does code reuse mean in practice?</h4>\r\n\r\n<p>Once you notice that parts of your code are similar, \r\nyou probably can factor out these aspects and write the reusable code \r\nin a general library file so you won’t have to repeat yourself in the \r\noriginal places. \r\n</br>\r\nImagine that you are writing a simple game in which your player is walking \r\non a road trying to avoid hungry tigers that just escaped from a zoo. The code \r\nof the loose tigers will have a lot in common and here we can use object-oriented \r\npatterns. \r\n</p>\r\n\r\n<p>Let's get to practice! </p>\r\n<p>In your code editor, create two files with names like ‘run.js’ and ‘library.js’. \r\nIn run.js, let’s create an object that represents our first tiger, which I randomly \r\ncalled ‘bobo’.\r\n</p>\r\n\r\n<pre><code>var bobo = {};</code></pre>\r\n\r\n<p>It is important to understand that ‘var bobo’ stands for the idea of a variable, \r\nwhereas {} represents the idea of an in-memory object.\r\n</br>\r\nTo keep track of the location of the tiger, we assign the property loc to bobo. We add bobo.loc++ on a new line to get the tiger to move (of course, code in actual games \r\ncould look a lot more complicated, but let’s just stick to this to keep our example simple!). \r\n</br>\r\nIt is time to add another wild tiger to our game and call her ‘nola’! I also assigned \r\ndifferent locations to both tigers. Our code now looks like this:\r\n</p>\r\n\r\n<pre><code>var bobo = {loc:2};\r\nbobo.loc++;\r\nvar nola = {loc:7};\r\nnola.loc++\r\n</code></pre>\r\n\r\n<p>Even though this is an amazingly simplified example, see that we are repeating ourselves? \r\nWe are repeatedly building objects with a lot of common code. Let’s get to refactoring! \r\n</br>\r\nWe can write generalized code in library.js, and it would be a good start to write a function \r\nthat moves the tigers along the street. Our code now looks like so:</p>\r\n\r\n<pre><code>var move = function(tiger){\r\n  tiger.loc++;\r\n};\r\n</code></pre>\r\n\r\n<p>This function object can now operate on our simple tiger objects in run.js, which are also \r\nsimplified to look like this:</p>\r\n\r\n<pre><code>var bobo = {loc:2};\r\nmove(bobo);\r\nvar nola = {loc:7};\r\nmove(nola);\r\n</code></pre>\r\n\r\n<h4>Wait, why?</h4> \r\n\r\n<p>Hold on - why did we do this? Isn’t there more code now then when we started out? Actually, \r\nthere are two good reasons to make the change we did.\r\n</p>\r\n\r\n<p>First, our example is extremely oversimplified. Usually writing generalized code will \r\nprevent programmers from rewriting much larger blocks of code. A second and maybe even more \r\nimportant reason is that now, if you want to change the way your objects move, you can be \r\nconfident that you’ve made all the changes you need by editing the code in that single function. \r\nThere is no need to make changes to each of your tiger objects. </p>\r\n\r\n<p>We are not done yet! See that we are still repeating ourselves? It is this little piece: {loc:1}. \r\nAlthough the repeated code snippet is very tiny in our example, in practice this is rarely the \r\ncase and objects usually have a lot more properties. Let’s move the property to our library.\r\n</p>\r\n\r\n<p>Again, we can write a function that does repeated work for us. I’ve called the function tigerProps \r\nbecause it contains the properties that the tiger needs to be considered a tiger object. Let’s \r\nwrite the function like this:\r\n</p>\r\n\r\n<pre><code>var tigerProps = function(obj, loc) {\r\n  obj.loc = loc\r\n  return obj;\r\n};\r\n</code></pre>\r\n\r\n<p>In this example, ’obj’ refers to a tiger object as its input. When we call it to our tiger objects, \r\nwe expect the tigerProps function to add the .loc property to the objects. We also passed the location \r\nof the tigers to the tigerProps function so it knows what to set the location to. We can now rewrite \r\nour code in run.js to look like this:\r\n</p>\r\n\r\n<pre><code>var bobo = tigerProps({}, 2);\r\nmove(bobo);\r\nvar nola = tigerProps({}, 9);\r\nmove(nola);</code></pre>\r\n\r\n<p>The tigerProps function here is considered a Decorator.</p>\r\n\r\n<h4>Can Decorators do more?</h4>\r\n\r\n<p>We could call the move function bobo’ or ‘nola’ using dot notation, keeping in mind that functions \r\ncan be used as properties to an object:\r\n</p>\r\n\r\n<pre><code>var bobo = tigerProps({}, 2);\r\nbobo.move();\r\n</code></pre>\r\n\r\n<p>We will need to change the library.js file to match the following code: </p>\r\n\r\n<pre><code>var tigerProps = function(obj, loc) {\r\n  obj.loc = loc;\r\n  obj.move = move;\r\n  return obj;\r\n};</code></pre>\r\n\r\n<p>After doing this, we also need to make a small change to our move function. \r\nSince the function no longer takes a first argument, and instead takes the object \r\non the left of the dot as its target when it is invoked. We’ll use ‘this’ to refer \r\nto this object on the left at calltime. </p>\r\n\r\n<pre><code>var move = function() {\r\n  this.loc++\r\n};\r\n</code></pre>\r\n\r\n<p>Now the move function is available on all tigers! However, in our case it might \r\nbe unnecessary store the move function as a global variable. Instead, we could move \r\nit right into the Decorator function by refactoring our code like this:</p>\r\n\r\n<pre><code>var tigerProps = function(obj, loc) {\r\n  obj.loc = loc;\r\n  obj.move = function() {\r\n    this.loc++;\r\n  };\r\n  return obj;\r\n};\r\n</code></pre>\r\n\r\n<p>You could probably image though that this is not ideal either because with our \r\ncurrent solution a new move function is generated (and these functions have their \r\nown identities that would not pass a strict comparison operator) every time the tigerProps \r\nfunction gets called. This could take up a lot of memory if we create many tiger objects!\r\n</p>\r\n\r\n<p>We could improve our function by changing the keyword ‘this’ to ‘obj’. Now, each time \r\nwhen we call the function a new closure scope is created and obj will always refer to the \r\nsame tiger object.</p>\r\n\r\n<p>My <a href=\"http://www.sandrahallie.com/blogs/1\">next blog post</a> will iterate on improving this piece of code!</p>\r\n\r\n<i>This post was inspired by the course on Object-Oriented Javascript by Udacity and Hack Reactor.</i>\r\n\r\n</section>\r\n",
  topic: "JavaScript",
  created_at: "2016-03-21"
)
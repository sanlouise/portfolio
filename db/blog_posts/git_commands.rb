user = User.first

user.blogs.create!(
  title: "Git Commands",
  body: "<h4 class=“center”>Basic User Configuration</h4>\r\n\r\n<p>Set username and email local machine:</p>\r\n<code><pre><xmp>git config --global user.name “<your name>”\r\ngit config --global user.email “<your email>”</xmp></pre></code>\r\n\r\n<p>Set email current repository:</p>\r\n<code><pre><xmp>git config user.email “<your email>”</xmp></pre></code>\r\n\r\n<p>Check email current repository:</p>\r\n<code><pre><xmp>git config user.email </xmp></pre></code>\r\n\r\n<p>Ensuring that you don’t have to always type username and password:</p>\r\n<code><pre>git remote set-url origin git@github.com:username/repo.git</pre></code>\r\n\r\n\r\n<h4 class=“center”>Staging and Remotes</h4>\r\n\r\n<p>Git does not take care of access control. Instead, you can use hosted solutions like GitHub or BitBucket or self-manages solutions like Gitosis or Gitorious.</p>\r\n\r\n<p>Show unstaged differences since last commit. The first two are the same.</p>\r\n<code><pre>git diff\r\n\r\ngit diff HEAD</pre></code>\r\n\r\n<p>Show unstaged differences since specific past commit. Some options:</p>\r\n<code><pre>git diff HEAD^ //parent of latest commit\r\ngit diff HEAD^^ //grandparent of latest commit\r\ngit diff HEAD~5 //5 commits ago\r\ngit diff HEAD^ ..HEAD //second most recent commit vs. most recent commit</pre></code>\r\n\r\n<p>View staged differences:</p>\r\n<code><pre>git diff --staged</pre></code>\r\n\r\n<p>Compare diffs between specific commits:</p>\r\n<code><pre><xmp>git diff <commit>..<other commit></xmp></pre></code>\r\n\r\n<p>Compare diffs between specific branches:</p>\r\n<code><pre><xmp>git diff <first branch>..<second branch></xmp></pre></code>\r\n\r\n<p>Unstage files:</p>\r\n<code><pre>git reset HEAD filename</pre></code>\r\n\r\n<p>Discard changes, reset file to what it was at last commit :</p>\r\n<code><pre>git checkout -- filename</pre></code>\r\n\r\n<p>Skip staging and commit. This adds all changes from tracked files and commits them:</p>\r\n<code><pre>git commit -a -m “Commit message”</pre></code>\r\n\r\n<p>Add a remote (here, origin is our remote name):</p>\r\n<code><pre><xmp>git remote add origin <address></xmp></pre></code>\r\n\r\n<p>Show remote repositories:</p>\r\n<code><pre>git remote -v</pre></code>\r\n\r\n<p>Push to remote repository:</p>\r\n<code><pre>git push -u origin master</pre></code>\r\n\r\n<p>Pull from remote repository:</p>\r\n<code><pre>git pull</pre></code>\r\n\r\n<p>Pull data from remote repository without merging:</p>\r\n<code><pre>git fetch</pre></code>\r\n\r\n<h5 class=“center”>Having Multiple Remotes</h5>\r\n<p>Add new remote:</p>\r\n<code><pre><xmp>git remote add <name> <address></xmp></pre></code>\r\n\r\n<p>Remove remote:</p>\r\n<code><pre><xmp>git remote rm <name></xmp></pre></code>\r\n\r\n<p>Push to remote:</p>\r\n<code><pre><xmp>git push -u <name> <branch></xmp></pre></code>\r\n\r\n<h5 class=“center”>Don’t Do These After You Push</h5>\r\n\r\n<p>Undo a commit, reset into staging:</p>\r\n<code><pre>git reset --soft HEAD^</pre></code>\r\n\r\n<p>Throw away last commit, undo all changes:</p>\r\n<code><pre>git reset --hard HEAD^</pre></code>\r\n\r\n<p>Throw away last two commits, undo all changes:</p>\r\n<code><pre>git reset --hard HEAD^^</pre></code>\r\n\r\n<p>Add a file to the last commit. Message overrides previous message:</p>\r\n<code><pre>git commit --amend -m “New commit message”</pre></code>\r\n\r\n<h4 class=“center”>Cloning and Branching</h4>\r\n<p>Clone a repo:</p>\r\n<code><pre><xmp>git clone <url></xmp></pre></code>\r\n\r\n<p>Clone a repo and change local folder name:</p>\r\n<code><pre><xmp>git clone <url> <name of choice></xmp></pre></code>\r\n\r\n<p>List remotes:</p>\r\n<code><pre>git remote -v</pre></code>\r\n\r\n<p>Branch out:</p>\r\n<code><pre><xmp>git branch <name of choice></xmp></pre></code>\r\n\r\n<p>Switch to branch:</p>\r\n<code><pre><xmp>git checkout <name of branch></xmp></pre></code>\r\n\r\n<p>Merge branch:</p>\r\n<code><pre><xmp>git checkout <branch you want to merge to>\u2028git merge <branch you want to merge></xmp></pre></code>\r\n\r\n<p>Delete branch:</p>\r\n<code><pre><xmp>git branch -d <name of branch></xmp></pre></code>\r\n\r\n<h4 class=“center”>Remote Branching</h4>\r\n\r\n<p>It can happen that you have a branch you want other people to contribute to. You’ll need to be able to push that branch remotely to allow other people to pull it and work on it until the file is ready to be merged back into master.</p>\r\n\r\n<p>Branch creator perspective: create a remote branch linked to local branch (tracking):</p>\r\n<code><pre><xmp>git checkout -b <name of new branch>\r\n\r\ngit push origin <name of newly created branch></xmp></pre></code>\r\n<p>Now commit the file like you normally would.</p>\r\n\r\n<p>Collaborator perspective: pull new branch, first list all remote branches:</p>\r\n<code><pre><xmp>git branch -r\r\ngit checkout <name of remote branch></xmp></pre></code>\r\n\r\n<p>Now we can contribute and push our code.</p>\r\n\r\n<p>Extremely useful: show all remote and local branches and show whether they are out-of-date:</p>\r\n<code><pre>git remote show origin</pre></code>\r\n\r\n<p>Remove a remote branch:</p>\r\n<code><pre><xmp>git push origin :<name of branch></xmp></pre></code>\r\n\r\n<p>Remove a local branch:</p>\r\n<code><pre><xmp>git branch -d <name of branch> \r\nOR \r\ngit branch -D <name of branch></xmp></pre></code>\r\n\r\n<p>The latter will force delete the branch even if the branch was not fully merged.</p>\r\n\r\n<p>Remove references to branches after someone else deleted them:</p>\r\n<code><pre>git remote prune origin</pre></code>\r\n\r\n<p>Push and deploy to Heroku with branch name other than ‘master’:</p>\r\n<code><pre><xmp>git push heroku-staging <name of branch>:master</xmp></pre></code>\r\n\r\n<h4 class=“center”>Tags</h4>\r\n<p>Tags are references to a specific commit. They are widely used for versioning of software.</p>\r\n\r\n<p>List all tags:</p>\r\n<code><pre>git tag</pre></code>\r\n\r\n<p>Go back to state of specific tag:</p>\r\n<code><pre><xmp>git checkout <tag name></xmp></pre></code>\r\n\r\n<p>Add a new tag (latter is an example):</p>\r\n<code><pre><xmp>git tag -a <tag name> -m “Commit message”\r\ngit tag -a v.0.2.3 -m “version 0.2.3”\r\n</xmp></pre></code>\r\n\r\n<p>Push new tags to remote:</p>\r\n<code><pre>git push --tags</pre></code>\r\n\r\n<h4 class=“center”>Rebase</h4>\r\n<p>Some view merge commits as bad, they could ‘pollute’ the commit history of a project. At times they feel useless. The alternative to merge commits is rebase. Instead of doing <code>git pull</code> and <code>git push</code>, we do <code>git fetch</code> and <code>git rebase</code>.</p>\r\n\r\n<p>As you might know, <code>git fetch</code> syncs our code with a remote without merging. Then, <code>git rebase</code> moves all changes to our master branch that are not in origin/master to a temporarily area. Then it runs all origin/master commits. Lastly, it runs all commits in the temporary area on top of our master branch, one at a time. No need for merge commits. </p>\r\n\r\n<p>Assume we have to branches: master and admin. The master branch is a few commits ahead of admin. Also, admin has changes that master does not know about. We can sync them like this:</p>\r\n<code><pre>git checkout admin //switched to branch ‘admin’\r\ngit rebase master \r\ngit checkout master //switched to branch ‘master’\r\ngit merge admin\r\n</pre></code>\r\n\r\n<p>First, all master commits are run. Then the additional admin commits are run. Then we check out the master branch and merge the admin commits back into master.</p>\r\n\r\n<h5 class=“center”>Conflicts</h5>\r\n<p>What if we run into an error because two people want to commit the same file, but they each have differently edited versions?</p>\r\n\r\n<p>Abort rebasing:</p>\r\n<code><pre>git rebase --abort</pre></code>\r\n\r\n<p>Fix merge conflict by editing the concerned file, then:</p>\r\n<code><pre><xmp>git add <name of edited file that caused conflict>\r\ngit rebase --continue</xmp></pre></code>\r\n\r\n<h4 class=“center”>History and Configuration</h4>\r\n<p>View log:</p>\r\n<code><pre>git log</pre></code>\r\n\r\n<p>Colorize log for readability:</p>\r\n<code><pre>git config --global color.ui true</pre></code>\r\n\r\n<p>Make log appear on one line:</p>\r\n<code><pre>git log --pretty=oneline</pre></code>\r\n\r\n<p>Format log (run git help log for config vars):</p>\r\n<code><pre>git log --pretty=format: “%h %ad- %s [%an]”</pre></code>\r\n\r\n<p>Show patch log, differences in code between commits:</p>\r\n<code><pre>git log --oneline -p</pre></code>\r\n\r\n<p>Show insertions and deletions:</p>\r\n<code><pre>git log --oneline --stat</pre></code>\r\n\r\n<p>Visualize branches commits in graph format:</p>\r\n<code><pre>git log --oneline --graph</pre></code>\r\n\r\n<p>Show logs with date range:</p>\r\n<code><pre>git log --until=1.minute.ago\r\ngit log --since=1.day.ago\r\ngit log --since=1.hour.ago\r\ngit log --since=1.month.ago --until=2.weeks.ago\r\ngit log --since=2000-01-01 --until=2012-12-21</pre></code>\r\n\r\n<p>Find out who committed what and when to a specific file:</p>\r\n<code><pre><xmp>git blame <filename></xmp></pre></code>\r\n\r\n<p>Exclude file or folder from committing in local repository. Move file or folder into:</p>\r\n<code><pre>.git/info/exclude</pre></code>\r\n\r\n<p>Exclude file or folder from all copies, also remotes. Always exclude log files (logs/*.log) to avoid merge conflicts. Move file or folder into:</p>\r\n<code><pre>.gitignore</pre></code>\r\n\r\n<p>Remove file from file system:</p>\r\n<code><pre><xmp>git rm <file name>\r\ngit commit -m “Commit message”</xmp></pre></code>\r\n\r\n<p>Stop tracking files. So file will be removed from Git but kept in local file system:</p>\r\n<code><pre><xmp>git rm --cached <file name></xmp></pre></code>\r\n\r\n<p>Set alias for long commands, some examples:</p>\r\n<code><pre>git config --global alias.mylog \\\r\n“git log --pretty=format: ‘%h %ad- %s [%an]’ --graph”\r\n\r\ngit config --global alias.st status //git st   for    git status\r\ngit config --global alias.co checkout //git co    for    git checkout\r\ngit config --global alias.ci commit //git ci    for    git commit</pre></code>\r\n\r\n<p>Set alias for super concise and beautiful log message:</p>\r\n<code><pre>git config --global alias.lol \\\r\n“log --graph --decorate --pretty=oneline --abbrev-commit --all”\r\n\r\n// then run \r\n\r\ngit mylog</pre></code>\r\n\r\n",
  topic: "CS Fundamentals",
  created_at: "2016-07-02"
)